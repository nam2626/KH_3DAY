-- 비밀번호 잊어 버렸을 때
sqlplus sys/oracle as sysdba
-- 관리자 비밀번호 변경
alter user system identified by 123456;
-- JDBC 드라이버 위치 : C:\app\user1\product\21c\dbhomeXE\jdbc\lib
-- 사용자 생성
CREATE USER C##ADMIN IDENTIFIED BY 123456;
-- 권한 적용
GRANT RESOURCE, CONNECT, CREATE VIEW TO C##ADMIN;
-- 저장소 사용량 부여
ALTER USER C##ADMIN DEFAULT TABLESPACE USERS QUOTA UNLIMITED ON USERS;  
-----------------------------------------------------------------------------
-- 데이터 타입
-- 문자열 : CHAR(2000까지 지원), VARCHAR2(4000), CLOB(128TB)
-- 숫자 : NUMBER(자리수, 소수점개수) -> 최대 38, FLOAT(128)
-- 날짜 시간 : DATE(날짜/시간), TIMESTAMP(소수점까지 저장 가능 최대 9자리)
-- https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/datatype-limits.html

-- CAR
-- 차량번호 - 문자 10개, 차량명, 제조사, 제조년도 - 정수 4자리, 금액 - 정수 5자리
-- 차량번호 --> A000000000
CREATE TABLE CAR(
	ID CHAR(10) PRIMARY KEY,
	CNAME VARCHAR2(50),
	MAKER VARCHAR2(50),
	MYEAR NUMBER(4),
	PRICE NUMBER(5)
);
-- 제약조건 삭제
ALTER TABLE CAR DROP CONSTRAINT SYS_C008314;
-- 제약조건 지정
ALTER TABLE CAR ADD CONSTRAINT PK_CAR PRIMARY KEY(ID);
-- 테이블 생성시 제약조건 지정
DROP TABLE CAR;

CREATE TABLE CAR(
	ID CHAR(10),
	CNAME VARCHAR2(50),
	MAKER VARCHAR2(50),
	MYEAR NUMBER(4),
	PRICE NUMBER(5),
	CONSTRAINT PK_CAR PRIMARY KEY(ID)
);

SELECT LENGTHB('바') FROM DUAL;

SELECT * FROM USER_CONSTRAINTS;

-- CAR 테이블 전체 조회
SELECT * FROM CAR;

-- 자동차 제조사만 조회
SELECT DISTINCT MAKER FROM CAR;
-- 제조사 데이터 건수 조회
SELECT COUNT(*) FROM (SELECT DISTINCT MAKER FROM CAR);
SELECT ROW_NUMBER() OVER(ORDER BY MAKER), MAKER FROM (SELECT DISTINCT MAKER FROM CAR);
-- 제조사별 데이터 건수
SELECT DISTINCT MAKER, COUNT(*) OVER(PARTITION BY MAKER)
FROM CAR;
-- 자동차의 제조사별 모델의 금액 순위
SELECT ID, CNAME, MAKER, RANK() OVER(PARTITION BY MAKER ORDER BY PRICE)
FROM CAR;

-- 옵션	설명
-- 'U'	대문자 알파벳
-- 'L'	소문자 알파벳
-- 'A'	대/소문자 알파벳
-- 'X'	대문자 알파벳 또는 숫자
-- 'P'	출력 가능한 모든 문자 (특수문자 포함)

SELECT DBMS_RANDOM.STRING('U', 1) || 
	TO_CHAR(ROW_NUMBER() OVER(ORDER BY MAKER),'FM00') AS MNO, MAKER 
FROM (SELECT DISTINCT MAKER FROM CAR);

-- 제조사 테이블 생성
CREATE TABLE CAR_MAKER
AS 
SELECT DBMS_RANDOM.STRING('U', 1) || 
	TO_CHAR(ROW_NUMBER() OVER(ORDER BY MAKER),'FM00') AS MNO, MAKER 
FROM (SELECT DISTINCT MAKER FROM CAR);

SELECT * FROM CAR_MAKER;

DROP TABLE CAR_MAKER;

CREATE TABLE CAR_MAKER(
	MNO CHAR(3),
	MAKER VARCHAR2(50),
	CONSTRAINT PK_CAR_MAKER PRIMARY KEY(MNO)
);

INSERT INTO CAR_MAKER(MNO, MAKER)
SELECT DBMS_RANDOM.STRING('U', 1) || 
	TO_CHAR(ROW_NUMBER() OVER(ORDER BY MAKER),'FM00') AS MNO, MAKER 
FROM (SELECT DISTINCT MAKER FROM CAR);

COMMIT;

TRUNCATE TABLE CAR_MAKER;

-- CAR 테이블에 MNO 컬럼 추가
ALTER TABLE CAR ADD MNO CHAR(3);

SELECT C. *, 
(SELECT CM.MNO FROM CAR_MAKER CM WHERE C.MAKER = CM.MAKER) AS MMAKER
FROM CAR C;
-- CAR 테이블에 MNO 데이터 수정
UPDATE CAR C
SET C.MNO = (SELECT DISTINCT CM.MNO FROM CAR_MAKER CM WHERE C.MAKER = CM.MAKER);
-- CAR 테이블에서 MAKER컬럼 삭제
ALTER TABLE CAR DROP COLUMN MAKER;
SELECT * FROM CAR;
-- CAR 테이블에서 MNO 컬럼을 외래키로 지정
ALTER TABLE CAR ADD CONSTRAINT FK_CAR_MNO 
FOREIGN KEY(MNO) REFERENCES CAR_MAKER(MNO);

-- 조인(JOIN)
-- 여러개 테이블에서 필요한 데이터를 조회하기 위해
-- 테이블을 결합해서 조회하기 위한 연산
-- 조인을 할려면 테이블끼리 연결 될 수 있는 동일한 데이터를 가지고 있는 컬럼이 있어야함
CREATE TABLE A(
	CODE CHAR(1),
	VAL NUMBER(1)
);
CREATE TABLE B(
	CODE CHAR(1),
	UNIT CHAR(1)
);
INSERT INTO A VALUES('A',1);
INSERT INTO A VALUES('B',2);
INSERT INTO A VALUES('C',3);
INSERT INTO A VALUES('D',4);

INSERT INTO B VALUES('A','+');
INSERT INTO B VALUES('B','-');
INSERT INTO B VALUES('C','*');
INSERT INTO B VALUES('F','/');

SELECT * FROM A;
SELECT * FROM B;

-- 동일 조인
SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A, B
WHERE A.CODE = B.CODE;

-- INNER JOIN
-- 조건을 만족하는 모든 행을 결함
SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A INNER JOIN B ON A.CODE = B.CODE;

SELECT A.CODE, A.VAL, B.CODE, B.UNIT 
FROM A JOIN B ON A.CODE = B.CODE;

-- NATURAL JOIN(자연 조인)
-- 자동으로 똑같은 컬럼을 찾아서 조인하고, 중복된 컬럼은 제거해서 조회
SELECT * FROM A NATURAL JOIN B;

-- CROSS JOIN
-- 교차 조인
-- 두 테이블의 모든 조합을 조회(모든 경우의 수)
SELECT * FROM A CROSS JOIN B;

-- 외부 조인(Outer JOIN)
SELECT * FROM A LEFT OUTER JOIN B ON A.CODE = B.CODE;
SELECT * FROM A RIGHT OUTER JOIN B ON A.CODE = B.CODE;

-- 오라클에서만 되는 외부 조인
SELECT * FROM A ,B WHERE A.CODE = B.CODE(+);

-- 불일치 쿼리
SELECT * FROM A LEFT OUTER JOIN B ON A.CODE = B.CODE
WHERE B.CODE IS NULL;

SELECT * FROM A WHERE A.CODE NOT IN(SELECT B.CODE FROM B);
-- EXISTS : 행이 존재하는가?
SELECT * FROM A WHERE EXISTS(SELECT 1 FROM B WHERE A.CODE = B.CODE);
SELECT * FROM A WHERE NOT EXISTS(SELECT 1 FROM B WHERE A.CODE = B.CODE);

-- WITH
-- 메인 쿼리가 실행되기 전에, 쿼리 내에서 사용할 수 있는 임시적인 명명된 결과 셋(Named Result Set)을 정의
-- WITH 절을 사용하는 목적은 복잡한 쿼리를 작은 블록으로 나누어 쿼리 구조를 쉽게 파악하기 위함.
-- 정의된 쿼리에서만 사용 가능, 다른 쿼리에서는 불가능
-- 해당 쿼리가 끝나면 사라짐.
WITH STUDENT_RANK AS (
    SELECT DENSE_RANK() OVER (ORDER BY S.SCORE DESC) AS SRANK,
    S.SNO, S.SNAME, M.MNAME, S.SCORE, S.GENDER
    FROM STUDENT S INNER JOIN MAJOR M ON S.MNO = M.MNO    
),
AVG_STUDENT_SCORE AS (
   SELECT AVG(SCORE) AS VAL FROM STUDENT
)
SELECT * FROM STUDENT_RANK
WHERE SRANK <= 3 OR SCORE <= (SELECT VAL FROM AVG_STUDENT_SCORE)
ORDER BY SRANK ASC;

